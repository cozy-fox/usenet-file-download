import { NextRequest, NextResponse } from 'next/server'
import { readdir, stat } from 'fs/promises'
import { join } from 'path'

export const dynamic = 'force-dynamic'

// File type mappings
const FILE_TYPES = {
  video: ['.mp4', '.avi', '.mkv', '.mov', '.wmv', '.flv', '.webm', '.m4v', '.3gp', '.ogv'],
  audio: ['.mp3', '.wav', '.flac', '.aac', '.ogg', '.wma', '.m4a', '.opus'],
  image: ['.jpg', '.jpeg', '.png', '.gif', '.bmp', '.webp', '.svg', '.tiff', '.ico'],
  book: ['.pdf', '.epub', '.mobi', '.azw', '.azw3', '.fb2', '.djvu', '.txt', '.rtf'],
  software: ['.exe', '.msi', '.dmg', '.pkg', '.deb', '.rpm', '.app', '.zip', '.tar', '.gz', '.7z', '.iso']
}

// Files to exclude (generated by projects)
const EXCLUDED_EXTENSIONS = ['.m3u', '.nfo', '.sfv', '.rar', '.par2', '.vol', '.rev', '.srr', '.nzb']

function getFileType(filename: string): 'video' | 'audio' | 'image' | 'book' | 'software' | null {
  const ext = filename.toLowerCase().substring(filename.lastIndexOf('.'))
  
  // Check if it's an excluded file
  if (EXCLUDED_EXTENSIONS.includes(ext)) {
    return null
  }
  
  // Check each file type
  for (const [type, extensions] of Object.entries(FILE_TYPES)) {
    if (extensions.includes(ext)) {
      return type as 'video' | 'audio' | 'image' | 'book' | 'software'
    }
  }
  
  return null
}

export async function GET(req: NextRequest) {
  try {
    const { searchParams } = new URL(req.url)
    const folderPath = searchParams.get('path')
    
    if (!folderPath) {
      return NextResponse.json(
        { success: false, error: 'Missing path parameter' },
        { status: 400 }
      )
    }
    
    // Read the folder contents
    const items = await readdir(folderPath)
    
    const files = []
    
    for (const item of items) {
      const itemPath = join(folderPath, item)
      const stats = await stat(itemPath)
      
      // Skip if it's a directory
      if (stats.isDirectory()) continue
      
      // Get file type (can be null for unsupported files)
      const fileType = getFileType(item)
      
      files.push({
        name: item,
        path: itemPath,
        size: stats.size,
        type: fileType, // Can be null for unsupported files
        supported: fileType !== null // Add flag to indicate if file is supported
      })
    }
    
    // Sort by supported status first, then by name
    files.sort((a, b) => {
      // Supported files first
      if (a.supported && !b.supported) return -1
      if (!a.supported && b.supported) return 1
      
      // If both have same support status, sort by name
      return a.name.localeCompare(b.name)
    })
    
    return NextResponse.json({
      success: true,
      data: files
    })
    
  } catch (error: any) {
    console.error('Error reading folder contents:', error)
    return NextResponse.json(
      { 
        success: false, 
        error: error.message || 'Failed to read folder contents' 
      },
      { status: 500 }
    )
  }
}
